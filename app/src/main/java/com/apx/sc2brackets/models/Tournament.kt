package com.apx.sc2brackets.models

import androidx.room.*
import com.apx.sc2brackets.db.DateTimeTypeConverter
import com.apx.sc2brackets.utils.dayEnd
import org.joda.time.DateTime

@Entity(indices = [Index(value = ["url"], unique = true)], tableName = "tournament")
@TypeConverters(DateTimeTypeConverter::class)
/**TournamentEntity "meaningful" primary key is [TournamentEntity.url]. However, we need autogenerated ID  to create
 * foreign key for `Matches` table.
 *
 * That means, before all INSERT/UPDATE/DELETE operations we need to check table for record with required url and
 * assign required ID to argument object.
 *
 * Probably not the best design:( Maybe switch to NoSQL?*/
data class TournamentEntity(
    val name: String?,
    val url: String,
    var lastUpdate: DateTime
) {
    @PrimaryKey(autoGenerate = true)
    var id: Int = 0
}

class Tournament(name: String? = null, url: String = "", lastUpdate: DateTime = DateTime.now()) {
    @Embedded
    var entity = TournamentEntity(name, url, lastUpdate)

    @Relation(entity = MatchEntity::class, parentColumn = "id", entityColumn = "tournament_id")
            /**List of played matches sorted by start order.*/
    var matches: List<Match> = emptyList()

    var lastUpdate: DateTime
        get() = entity.lastUpdate
        set(value) {
            entity.lastUpdate = value
        }

    val name get() = entity.name
    val url get() = entity.url

    fun copy(name: String? = null, url: String = "", lastUpdate: DateTime = DateTime.now()): Tournament =
        Tournament(name, url, lastUpdate).let {
            it.entity = entity.copy()
            it.matches = matches
            it
        }

    /**Returns match that is played right now in the tournament or null if no match is alive*/
    fun liveMatch(): Match? = matches.firstOrNull { it.isLive }

    /**Returns next match that will be played in tournament, if it is not over, else null.
     * If last match of the tournament is currently live, returns null.  */
    fun nextMatch(): Match? = matches.firstOrNull { !it.isBefore(DateTime.now()) }

    /**See [TournamentEntity] documentation for design reason*/
    var primaryKey: Int
        get() = entity.id
        set(value) {
            entity.id = value
        }

    val status: Status
        get() {
            val now = DateTime.now()
            val next = nextMatch()
            val startTime = next?.startTime
            when {
                matches.isEmpty() -> Status.NO_SCHEDULE
                next == null -> Status.ENDED
                startTime == null -> Status.NO_SCHEDULE
                startTime.isAfter(now.plusDays(SOON_TIME_DAYS)) -> Status.HAS_SCHEDULE
                startTime.isAfter(dayEnd(now)) -> Status.SOON
                liveMatch() != null -> Status.LIVE
                else-> Status.TODAY
            }
        }

    enum class Status {
        NO_SCHEDULE, HAS_SCHEDULE, SOON, TODAY, LIVE, ENDED_FOR_TODAY, ENDED
    }

    companion object {
        val DEFAULT_KNOWN_LIST = listOf(
            Tournament(
                name = "2019 WCS Spring: Europe Qualifier",
                url = "https://liquipedia.net/starcraft2/2019_WCS_Spring/Qualifiers/Europe"
            ),
            Tournament(
                name = "2019 WCS Spring: North America Qualifier",
                url = "https://liquipedia.net/starcraft2/2019_WCS_Spring/Qualifiers/North_America"
            ),
            Tournament(
                name = "IEM Season XIII - Katowice",
                url = "https://liquipedia.net/starcraft2/IEM_Season_XIII_-_Katowice"
            ),
            Tournament(
                name = "Red Hot Cup #1",
                url = "https://liquipedia.net/starcraft2/Red_Hot_Cup/1"
            )
        )
        private const val SOON_TIME_DAYS = 3
    }
}